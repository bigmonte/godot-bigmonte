From 142909da50a420ce973fda5d5878791faca25b2f Mon Sep 17 00:00:00 2001
From: lawnjelly <lawnjelly@gmail.com>
Date: Wed, 29 Jan 2020 13:01:38 +0000
Subject: [PATCH] Accelerate 2D by tracking state client-side

GLES2 only first.

Godot 2D performance is usually bottlenecked by the methods used with OpenGL, there are currently drawcalls per quad.

In this PR basic state tracking is added to rasterizer_canvas_gles2::_canvas_item_render_commands().

This gives a 'free' performance increase of around 40% frames per second in a test scene, while requiring minimal changes to the overall mechanism.
---
 drivers/gles2/rasterizer_canvas_gles2.cpp | 120 ++++++++++++++++------
 drivers/gles2/rasterizer_canvas_gles2.h   |  90 ++++++++++++++++
 drivers/gles3/rasterizer_canvas_gles3.cpp |   2 +
 servers/visual/rasterizer.h               |   5 +
 4 files changed, 185 insertions(+), 32 deletions(-)

diff --git a/drivers/gles2/rasterizer_canvas_gles2.cpp b/drivers/gles2/rasterizer_canvas_gles2.cpp
index 373d3989ce4..da9a115e986 100644
--- a/drivers/gles2/rasterizer_canvas_gles2.cpp
+++ b/drivers/gles2/rasterizer_canvas_gles2.cpp
@@ -543,6 +543,11 @@ static const GLenum gl_primitive[] = {
 
 void RasterizerCanvasGLES2::_canvas_item_render_commands(Item *p_item, Item *current_clip, bool &reclip, RasterizerStorageGLES2::Material *p_material) {
 
+	// We will keep track of what state we have set OpenGL to throughout rendering commands,
+	// in order to minimize OpenGL state changes. This struct keeps a record of state and performs
+	// housekeeping.
+	CommandState command_state(this);
+
 	int command_count = p_item->commands.size();
 	Item::Command **commands = p_item->commands.ptrw();
 
@@ -550,6 +555,10 @@ void RasterizerCanvasGLES2::_canvas_item_render_commands(Item *p_item, Item *cur
 
 		Item::Command *command = commands[i];
 
+		// if the command type has changed, we should release the previous state
+		// so that OpenGL is left in some 'convention' (this may not be required but may be relied on by other code)
+		bool command_type_changed = command_state.release(command->type);
+
 		switch (command->type) {
 
 			case Item::Command::TYPE_LINE: {
@@ -616,24 +625,51 @@ void RasterizerCanvasGLES2::_canvas_item_render_commands(Item *p_item, Item *cur
 
 				Item::CommandRect *r = static_cast<Item::CommandRect *>(command);
 
-				glDisableVertexAttribArray(VS::ARRAY_COLOR);
-				glVertexAttrib4fv(VS::ARRAY_COLOR, r->modulate.components);
+				if (!command_state.complete)
+					glDisableVertexAttribArray(VS::ARRAY_COLOR);
+
+				const Color &current_state_color = r->modulate;
+
+				if (current_state_color != command_state.color) {
+					glVertexAttrib4fv(VS::ARRAY_COLOR, current_state_color.components);
+					command_state.color = current_state_color;
+				}
 
 				bool can_tile = true;
-				if (r->texture.is_valid() && r->flags & CANVAS_RECT_TILE && !storage->config.support_npot_repeat_mipmap) {
+
+				// if we have previously recorded that we are fake tiling
+				if (command_state.force_repeat) {
+					can_tile = false;
+				}
+
+				// if the texture has changed (it will always change at the start of a state, unless the texture is NULL)
+				// we must check if it is non-POT
+				if (command_state.RID_texture != r->texture) {
 					// workaround for when setting tiling does not work due to hardware limitation
+					if (!storage->config.support_npot_repeat_mipmap) {
+						bool force_repeat = false;
 
-					RasterizerStorageGLES2::Texture *texture = storage->texture_owner.getornull(r->texture);
+						if (r->texture.is_valid() && r->flags & CANVAS_RECT_TILE) {
 
-					if (texture) {
+							RasterizerStorageGLES2::Texture *texture = storage->texture_owner.getornull(r->texture);
+
+							if (texture) {
+
+								texture = texture->get_ptr();
 
-						texture = texture->get_ptr();
+								if (next_power_of_2(texture->alloc_width) != (unsigned int)texture->alloc_width && next_power_of_2(texture->alloc_height) != (unsigned int)texture->alloc_height) {
 
-						if (next_power_of_2(texture->alloc_width) != (unsigned int)texture->alloc_width && next_power_of_2(texture->alloc_height) != (unsigned int)texture->alloc_height) {
-							state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_FORCE_REPEAT, true);
+									force_repeat = true;
+								}
+							}
+						}
+
+						command_state.set_force_repeat(force_repeat);
+						if (force_repeat) {
 							can_tile = false;
 						}
-					}
+
+					} // if not support non POT
 				}
 
 				// On some widespread Nvidia cards, the normal draw method can produce some
@@ -720,20 +756,45 @@ void RasterizerCanvasGLES2::_canvas_item_render_commands(Item *p_item, Item *cur
 						_draw_gui_primitive(4, points, NULL, uvs);
 					}
 
+					glBindBuffer(GL_ARRAY_BUFFER, 0);
+					glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
+
 				} else {
 					// This branch is better for performance, but can produce flicker on Nvidia, see above comment.
-					_bind_quad_buffer();
 
-					state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_TEXTURE_RECT, true);
+					if (command_type_changed && !command_state.complete) {
+						_bind_quad_buffer();
 
-					if (state.canvas_shader.bind()) {
-						_set_uniforms();
-						state.canvas_shader.use_material((void *)p_material);
+						state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_TEXTURE_RECT, true);
+
+						if (state.canvas_shader.bind()) {
+							_set_uniforms();
+							state.canvas_shader.use_material((void *)p_material);
+						}
 					}
 
-					RasterizerStorageGLES2::Texture *tex = _bind_canvas_texture(r->texture, r->normal_map);
+					RasterizerStorageGLES2::Texture *tex;
+					if ((!command_type_changed) && (r->texture == command_state.RID_texture) && (r->normal_map == command_state.RID_normal)) {
+						tex = command_state.current_tex;
+					} else {
+						tex = _bind_canvas_texture(r->texture, r->normal_map);
+						command_state.RID_texture = r->texture;
+						command_state.RID_normal = r->normal_map;
+						command_state.current_tex = tex;
+
+						if (tex) {
+							command_state.tex_pixel_size.x = 1.0 / tex->width;
+							command_state.tex_pixel_size.y = 1.0 / tex->height;
+						}
+
+						// mark the cstate as incomplete, because the texture has changed...
+						// and we may need to resend uniforms
+						// this catches the case where the command type is the same (i.e. Rects) but the texture has changed.
+						command_state.complete = false;
+					}
 
 					if (!tex) {
+
 						Rect2 dst_rect = Rect2(r->rect.position, r->rect.size);
 
 						if (dst_rect.size.width < 0) {
@@ -751,15 +812,11 @@ void RasterizerCanvasGLES2::_canvas_item_render_commands(Item *p_item, Item *cur
 						glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
 					} else {
 
-						bool untile = false;
+						// decide whether to tile and tell OpenGL but only if state changed
+						command_state.set_tiling(can_tile && r->flags & CANVAS_RECT_TILE && !(tex->flags & VS::TEXTURE_FLAG_REPEAT));
 
-						if (can_tile && r->flags & CANVAS_RECT_TILE && !(tex->flags & VS::TEXTURE_FLAG_REPEAT)) {
-							glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
-							glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
-							untile = true;
-						}
+						const Size2 &texpixel_size = command_state.tex_pixel_size;
 
-						Size2 texpixel_size(1.0 / tex->width, 1.0 / tex->height);
 						Rect2 src_rect = (r->flags & CANVAS_RECT_REGION) ? Rect2(r->source.position * texpixel_size, r->source.size * texpixel_size) : Rect2(0, 0, 1, 1);
 
 						Rect2 dst_rect = Rect2(r->rect.position, r->rect.size);
@@ -785,24 +842,18 @@ void RasterizerCanvasGLES2::_canvas_item_render_commands(Item *p_item, Item *cur
 							dst_rect.size.x *= -1; // Encoding in the dst_rect.z uniform
 						}
 
-						state.canvas_shader.set_uniform(CanvasShaderGLES2::COLOR_TEXPIXEL_SIZE, texpixel_size);
+						if (!command_state.complete)
+							state.canvas_shader.set_uniform(CanvasShaderGLES2::COLOR_TEXPIXEL_SIZE, texpixel_size);
 
 						state.canvas_shader.set_uniform(CanvasShaderGLES2::DST_RECT, Color(dst_rect.position.x, dst_rect.position.y, dst_rect.size.x, dst_rect.size.y));
 						state.canvas_shader.set_uniform(CanvasShaderGLES2::SRC_RECT, Color(src_rect.position.x, src_rect.position.y, src_rect.size.x, src_rect.size.y));
 
 						glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
-
-						if (untile) {
-							glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
-							glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
-						}
 					}
-
-					glBindBuffer(GL_ARRAY_BUFFER, 0);
-					glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
 				}
 
-				state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_FORCE_REPEAT, false);
+				// this ensures uniforms etc aren't resent to OpenGL unless something changes
+				command_state.complete = true;
 
 			} break;
 
@@ -1352,7 +1403,12 @@ void RasterizerCanvasGLES2::_canvas_item_render_commands(Item *p_item, Item *cur
 				//print_line("other");
 			} break;
 		}
+
+		command_state.type = command->type;
 	}
+
+	// when exiting the routine, make sure openGL is left in default state
+	command_state.release(Item::Command::TYPE_NULL);
 }
 
 void RasterizerCanvasGLES2::_copy_screen(const Rect2 &p_rect) {
diff --git a/drivers/gles2/rasterizer_canvas_gles2.h b/drivers/gles2/rasterizer_canvas_gles2.h
index f6ae6a60c05..a975b588e78 100644
--- a/drivers/gles2/rasterizer_canvas_gles2.h
+++ b/drivers/gles2/rasterizer_canvas_gles2.h
@@ -98,6 +98,29 @@ class RasterizerCanvasGLES2 : public RasterizerCanvas {
 
 	} state;
 
+	struct CommandState {
+		CommandState(RasterizerCanvasGLES2 *p_owner) {
+			reset();
+			owner = p_owner;
+		}
+
+		void reset();
+		bool release(Item::Command::Type p_command_type);
+		void set_force_repeat(bool p_repeat);
+		void set_tiling(bool p_tile);
+
+		Item::Command::Type type;
+		bool complete; // whether state change is completed
+		bool tiling;
+		bool force_repeat;
+		RID RID_texture;
+		RID RID_normal;
+		RasterizerStorageGLES2::Texture *current_tex;
+		Size2 tex_pixel_size;
+		Color color;
+		RasterizerCanvasGLES2 *owner;
+	};
+
 	typedef void Texture;
 
 	RasterizerSceneGLES2 *scene_render;
@@ -145,4 +168,71 @@ class RasterizerCanvasGLES2 : public RasterizerCanvas {
 	RasterizerCanvasGLES2();
 };
 
+// clear our internal records of state
+inline void RasterizerCanvasGLES2::CommandState::reset() {
+	complete = false;
+	tiling = false;
+	force_repeat = false;
+	RID_texture = RID();
+	RID_normal = RID();
+	current_tex = 0;
+	color.a = -1; // just to ensure a difference is found
+	type = Item::Command::TYPE_NULL;
+}
+
+// return whether command type changed
+inline bool RasterizerCanvasGLES2::CommandState::release(Item::Command::Type p_command_type) {
+	// noop, no state change
+	if (p_command_type == type)
+		return false;
+
+	// this will always occur on the first command item
+	if (type == Item::Command::TYPE_NULL)
+		return true; // nothing to do
+
+	// put opengl back into a 'default' state when finishing a 'batch' of similar commands
+	switch (type) {
+		// only dealing with speeding up rects so far
+		case Item::Command::TYPE_RECT: {
+			// only considering one case for now
+			if (!owner->use_nvidia_rect_workaround) {
+				set_tiling(false);
+				set_force_repeat(false);
+				glBindBuffer(GL_ARRAY_BUFFER, 0);
+				glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
+			}
+		} break;
+		default:
+			break;
+	}
+
+	reset();
+
+	return true;
+}
+
+inline void RasterizerCanvasGLES2::CommandState::set_force_repeat(bool p_repeat) {
+	// noop
+	if (p_repeat == force_repeat)
+		return;
+
+	owner->state.canvas_shader.set_conditional(CanvasShaderGLES2::USE_FORCE_REPEAT, p_repeat);
+	force_repeat = p_repeat;
+}
+
+inline void RasterizerCanvasGLES2::CommandState::set_tiling(bool p_tile) {
+	// noop?
+	if (p_tile == tiling)
+		return;
+
+	if (p_tile) {
+		glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
+		glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
+	} else {
+		glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+		glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+	}
+	tiling = p_tile;
+}
+
 #endif // RASTERIZERCANVASGLES2_H
diff --git a/drivers/gles3/rasterizer_canvas_gles3.cpp b/drivers/gles3/rasterizer_canvas_gles3.cpp
index b7b31c66aa3..4980d7e0903 100644
--- a/drivers/gles3/rasterizer_canvas_gles3.cpp
+++ b/drivers/gles3/rasterizer_canvas_gles3.cpp
@@ -1250,6 +1250,8 @@ void RasterizerCanvasGLES3::_canvas_item_render_commands(Item *p_item, Item *cur
 				}
 
 			} break;
+			case Item::Command::TYPE_NULL: {
+			} break;
 		}
 	}
 }
diff --git a/servers/visual/rasterizer.h b/servers/visual/rasterizer.h
index 0008b809b78..202e50bb137 100644
--- a/servers/visual/rasterizer.h
+++ b/servers/visual/rasterizer.h
@@ -684,6 +684,7 @@ class RasterizerCanvas {
 
 			enum Type {
 
+				TYPE_NULL,
 				TYPE_LINE,
 				TYPE_POLYLINE,
 				TYPE_RECT,
@@ -1008,6 +1009,10 @@ class RasterizerCanvas {
 					case Item::Command::TYPE_CLIP_IGNORE: {
 
 					} break;
+
+					case Item::Command::TYPE_NULL: {
+
+					} break;
 				}
 
 				if (found_xform) {

