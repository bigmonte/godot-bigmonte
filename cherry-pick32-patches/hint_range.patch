From 22ad83edaec654bf26a46403024cb07a41e9a636 Mon Sep 17 00:00:00 2001
From: Yuri Roubinsky <chaosus89@gmail.com>
Date: Thu, 6 Feb 2020 15:11:03 +0300
Subject: [PATCH] Implemented hint_range for VisualShaderNodeScalarUniform

---
 doc/classes/VisualShaderNodeScalarUniform.xml | 25 ++++++
 .../plugins/visual_shader_editor_plugin.cpp   | 35 +++++++-
 scene/resources/visual_shader_nodes.cpp       | 81 +++++++++++++++++++
 scene/resources/visual_shader_nodes.h         | 32 ++++++++
 4 files changed, 170 insertions(+), 3 deletions(-)

diff --git a/doc/classes/VisualShaderNodeScalarUniform.xml b/doc/classes/VisualShaderNodeScalarUniform.xml
index d1a47425559..fab766d3f92 100644
--- a/doc/classes/VisualShaderNodeScalarUniform.xml
+++ b/doc/classes/VisualShaderNodeScalarUniform.xml
@@ -1,13 +1,38 @@
 <?xml version="1.0" encoding="UTF-8" ?>
 <class name="VisualShaderNodeScalarUniform" inherits="VisualShaderNodeUniform" version="4.0">
 	<brief_description>
+		A scalar uniform to be used within the visual shader graph.
 	</brief_description>
 	<description>
+		Translated to [code]uniform float[/code] in the shader language.
 	</description>
 	<tutorials>
 	</tutorials>
 	<methods>
 	</methods>
+	<members>
+		<member name="hint" type="int" setter="set_hint" getter="get_hint" enum="VisualShaderNodeScalarUniform.Hint" default="0">
+			A hint applied to the uniform, which controls the values it can take when set through the inspector.
+		</member>
+		<member name="max" type="float" setter="set_max" getter="get_max" default="1.0">
+			Minimum value for range hints. Used if [member hint] is set to [constant HINT_RANGE] or [constant HINT_RANGE_STEP].
+		</member>
+		<member name="min" type="float" setter="set_min" getter="get_min" default="0.0">
+			Maximum value for range hints. Used if [member hint] is set to [constant HINT_RANGE] or [constant HINT_RANGE_STEP].
+		</member>
+		<member name="step" type="float" setter="set_step" getter="get_step" default="0.1">
+			Step (increment) value for the range hint with step. Used if [member hint] is set to [constant HINT_RANGE_STEP].
+		</member>
+	</members>
 	<constants>
+		<constant name="HINT_NONE" value="0" enum="Hint">
+			No hint used.
+		</constant>
+		<constant name="HINT_RANGE" value="1" enum="Hint">
+			A range hint for scalar value, which limits possible input values between [member min] and [member max]. Translated to [code]hint_range(min, max)[/code] in shader code.
+		</constant>
+		<constant name="HINT_RANGE_STEP" value="2" enum="Hint">
+			A range hint for scalar value with step, which limits possible input values between [member min] and [member max], with a step (increment) of [member step]). Translated to [code]hint_range(min, max, step)[/code] in shader code.
+		</constant>
 	</constants>
 </class>
diff --git a/editor/plugins/visual_shader_editor_plugin.cpp b/editor/plugins/visual_shader_editor_plugin.cpp
index e334d4b0939..fb095692bca 100644
--- a/editor/plugins/visual_shader_editor_plugin.cpp
+++ b/editor/plugins/visual_shader_editor_plugin.cpp
@@ -556,6 +556,7 @@ void VisualShaderEditor::_update_graph() {
 		}
 
 		Ref<VisualShaderNodeUniform> uniform = vsnode;
+		Ref<VisualShaderNodeScalarUniform> scalar_uniform = vsnode;
 		if (uniform.is_valid()) {
 			graph->add_child(node);
 			_update_created_node(node);
@@ -570,7 +571,9 @@ void VisualShaderEditor::_update_graph() {
 				//shortcut
 				VisualShaderNode::PortType port_right = vsnode->get_output_port_type(0);
 				node->set_slot(0, false, VisualShaderNode::PORT_TYPE_SCALAR, Color(), true, port_right, type_color[port_right]);
-				continue;
+				if (!scalar_uniform.is_valid()) {
+					continue;
+				}
 			}
 			port_offset++;
 		}
@@ -582,11 +585,16 @@ void VisualShaderEditor::_update_graph() {
 			}
 		}
 
-		if (custom_editor && vsnode->get_output_port_count() > 0 && vsnode->get_output_port_name(0) == "" && (vsnode->get_input_port_count() == 0 || vsnode->get_input_port_name(0) == "")) {
+		if (custom_editor && !scalar_uniform.is_valid() && vsnode->get_output_port_count() > 0 && vsnode->get_output_port_name(0) == "" && (vsnode->get_input_port_count() == 0 || vsnode->get_input_port_name(0) == "")) {
 			//will be embedded in first port
 		} else if (custom_editor) {
+
 			port_offset++;
 			node->add_child(custom_editor);
+			if (scalar_uniform.is_valid()) {
+				custom_editor->call_deferred("_show_prop_names", true);
+				continue;
+			}
 			custom_editor = NULL;
 		}
 
@@ -2972,6 +2980,13 @@ class VisualShaderNodePluginDefaultEditor : public VBoxContainer {
 	bool updating;
 	Ref<VisualShaderNode> node;
 	Vector<EditorProperty *> properties;
+	Vector<Label *> prop_names;
+
+	void _show_prop_names(bool p_show) {
+		for (int i = 0; i < prop_names.size(); i++) {
+			prop_names[i]->set_visible(p_show);
+		}
+	}
 
 	void setup(Ref<Resource> p_parent_resource, Vector<EditorProperty *> p_properties, const Vector<StringName> &p_names, Ref<VisualShaderNode> p_node) {
 		parent_resource = p_parent_resource;
@@ -2981,7 +2996,20 @@ class VisualShaderNodePluginDefaultEditor : public VBoxContainer {
 
 		for (int i = 0; i < p_properties.size(); i++) {
 
-			add_child(p_properties[i]);
+			HBoxContainer *hbox = memnew(HBoxContainer);
+			hbox->set_h_size_flags(SIZE_EXPAND_FILL);
+			add_child(hbox);
+
+			Label *prop_name = memnew(Label);
+			String prop_name_str = p_names[i];
+			prop_name_str = prop_name_str.capitalize() + ":";
+			prop_name->set_text(prop_name_str);
+			prop_name->set_visible(false);
+			hbox->add_child(prop_name);
+			prop_names.push_back(prop_name);
+
+			p_properties[i]->set_h_size_flags(SIZE_EXPAND_FILL);
+			hbox->add_child(p_properties[i]);
 
 			bool res_prop = Object::cast_to<EditorPropertyResource>(p_properties[i]);
 			if (res_prop) {
@@ -3003,6 +3031,7 @@ class VisualShaderNodePluginDefaultEditor : public VBoxContainer {
 		ClassDB::bind_method("_refresh_request", &VisualShaderNodePluginDefaultEditor::_refresh_request);
 		ClassDB::bind_method("_resource_selected", &VisualShaderNodePluginDefaultEditor::_resource_selected);
 		ClassDB::bind_method("_open_inspector", &VisualShaderNodePluginDefaultEditor::_open_inspector);
+		ClassDB::bind_method("_show_prop_names", &VisualShaderNodePluginDefaultEditor::_show_prop_names);
 	}
 };
 
diff --git a/scene/resources/visual_shader_nodes.cpp b/scene/resources/visual_shader_nodes.cpp
index daf770e92a1..8f0e0058eaa 100644
--- a/scene/resources/visual_shader_nodes.cpp
+++ b/scene/resources/visual_shader_nodes.cpp
@@ -3039,6 +3039,11 @@ String VisualShaderNodeScalarUniform::get_output_port_name(int p_port) const {
 }
 
 String VisualShaderNodeScalarUniform::generate_global(Shader::Mode p_mode, VisualShader::Type p_type, int p_id) const {
+	if (hint == HINT_RANGE) {
+		return "uniform float " + get_uniform_name() + " : hint_range(" + rtos(hint_range_min) + ", " + rtos(hint_range_max) + ");\n";
+	} else if (hint == HINT_RANGE_STEP) {
+		return "uniform float " + get_uniform_name() + " : hint_range(" + rtos(hint_range_min) + ", " + rtos(hint_range_max) + ", " + rtos(hint_range_step) + ");\n";
+	}
 	return "uniform float " + get_uniform_name() + ";\n";
 }
 
@@ -3046,7 +3051,83 @@ String VisualShaderNodeScalarUniform::generate_code(Shader::Mode p_mode, VisualS
 	return "\t" + p_output_vars[0] + " = " + get_uniform_name() + ";\n";
 }
 
+void VisualShaderNodeScalarUniform::set_hint(Hint p_hint) {
+	hint = p_hint;
+	emit_changed();
+}
+
+VisualShaderNodeScalarUniform::Hint VisualShaderNodeScalarUniform::get_hint() const {
+	return hint;
+}
+
+void VisualShaderNodeScalarUniform::set_min(float p_value) {
+	hint_range_min = p_value;
+	emit_changed();
+}
+
+float VisualShaderNodeScalarUniform::get_min() const {
+	return hint_range_min;
+}
+
+void VisualShaderNodeScalarUniform::set_max(float p_value) {
+	hint_range_max = p_value;
+	emit_changed();
+}
+
+float VisualShaderNodeScalarUniform::get_max() const {
+	return hint_range_max;
+}
+
+void VisualShaderNodeScalarUniform::set_step(float p_value) {
+	hint_range_step = p_value;
+	emit_changed();
+}
+
+float VisualShaderNodeScalarUniform::get_step() const {
+	return hint_range_step;
+}
+
+void VisualShaderNodeScalarUniform::_bind_methods() {
+	ClassDB::bind_method(D_METHOD("set_hint", "hint"), &VisualShaderNodeScalarUniform::set_hint);
+	ClassDB::bind_method(D_METHOD("get_hint"), &VisualShaderNodeScalarUniform::get_hint);
+
+	ClassDB::bind_method(D_METHOD("set_min", "value"), &VisualShaderNodeScalarUniform::set_min);
+	ClassDB::bind_method(D_METHOD("get_min"), &VisualShaderNodeScalarUniform::get_min);
+
+	ClassDB::bind_method(D_METHOD("set_max", "value"), &VisualShaderNodeScalarUniform::set_max);
+	ClassDB::bind_method(D_METHOD("get_max"), &VisualShaderNodeScalarUniform::get_max);
+
+	ClassDB::bind_method(D_METHOD("set_step", "value"), &VisualShaderNodeScalarUniform::set_step);
+	ClassDB::bind_method(D_METHOD("get_step"), &VisualShaderNodeScalarUniform::get_step);
+
+	ADD_PROPERTY(PropertyInfo(Variant::INT, "hint", PROPERTY_HINT_ENUM, "None,Range,Range+Step"), "set_hint", "get_hint");
+	ADD_PROPERTY(PropertyInfo(Variant::REAL, "min"), "set_min", "get_min");
+	ADD_PROPERTY(PropertyInfo(Variant::REAL, "max"), "set_max", "get_max");
+	ADD_PROPERTY(PropertyInfo(Variant::REAL, "step"), "set_step", "get_step");
+
+	BIND_ENUM_CONSTANT(HINT_NONE);
+	BIND_ENUM_CONSTANT(HINT_RANGE);
+	BIND_ENUM_CONSTANT(HINT_RANGE_STEP);
+}
+
+Vector<StringName> VisualShaderNodeScalarUniform::get_editable_properties() const {
+	Vector<StringName> props;
+	props.push_back("hint");
+	if (hint == HINT_RANGE || hint == HINT_RANGE_STEP) {
+		props.push_back("min");
+		props.push_back("max");
+	}
+	if (hint == HINT_RANGE_STEP) {
+		props.push_back("step");
+	}
+	return props;
+}
+
 VisualShaderNodeScalarUniform::VisualShaderNodeScalarUniform() {
+	hint = HINT_NONE;
+	hint_range_min = 0.0;
+	hint_range_max = 1.0;
+	hint_range_step = 0.1;
 }
 
 ////////////// Boolean Uniform
diff --git a/scene/resources/visual_shader_nodes.h b/scene/resources/visual_shader_nodes.h
index cca37273d94..3d57fd0efc9 100644
--- a/scene/resources/visual_shader_nodes.h
+++ b/scene/resources/visual_shader_nodes.h
@@ -1300,6 +1300,22 @@ class VisualShaderNodeTransformDecompose : public VisualShaderNode {
 class VisualShaderNodeScalarUniform : public VisualShaderNodeUniform {
 	GDCLASS(VisualShaderNodeScalarUniform, VisualShaderNodeUniform);
 
+public:
+	enum Hint {
+		HINT_NONE,
+		HINT_RANGE,
+		HINT_RANGE_STEP,
+	};
+
+private:
+	Hint hint;
+	float hint_range_min;
+	float hint_range_max;
+	float hint_range_step;
+
+protected:
+	static void _bind_methods();
+
 public:
 	virtual String get_caption() const;
 
@@ -1314,9 +1330,25 @@ class VisualShaderNodeScalarUniform : public VisualShaderNodeUniform {
 	virtual String generate_global(Shader::Mode p_mode, VisualShader::Type p_type, int p_id) const;
 	virtual String generate_code(Shader::Mode p_mode, VisualShader::Type p_type, int p_id, const String *p_input_vars, const String *p_output_vars, bool p_for_preview = false) const; //if no output is connected, the output var passed will be empty. if no input is connected and input is NIL, the input var passed will be empty
 
+	void set_hint(Hint p_hint);
+	Hint get_hint() const;
+
+	void set_min(float p_value);
+	float get_min() const;
+
+	void set_max(float p_value);
+	float get_max() const;
+
+	void set_step(float p_value);
+	float get_step() const;
+
+	virtual Vector<StringName> get_editable_properties() const;
+
 	VisualShaderNodeScalarUniform();
 };
 
+VARIANT_ENUM_CAST(VisualShaderNodeScalarUniform::Hint)
+
 ///////////////////////////////////////
 
 class VisualShaderNodeBooleanUniform : public VisualShaderNodeUniform {

