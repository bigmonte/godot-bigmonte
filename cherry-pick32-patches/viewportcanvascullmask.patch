From ea358a58ba2bd7a1ea8b6e7aad4f8c58fee2dfb0 Mon Sep 17 00:00:00 2001
From: Valentin Zagura <puthre@gmail.com>
Date: Mon, 2 Sep 2019 00:01:57 +0100
Subject: [PATCH] Added Viewport canvas cull mask feature There was no way to
 render canvasitems in specific viewports and this commit fixes that. Added
 "Layers" property to canvas items and "Canvas Cull Mask" property to
 viewports so you can now enable / disable layers of canvas items per
 viewport. Hopefully this will also help in adding effects to nodes (like
 glow) that need rendering to texture.

---
 scene/2d/canvas_item.cpp                  | 38 ++++++++++++++++++--
 scene/2d/canvas_item.h                    |  8 +++++
 scene/main/viewport.cpp                   | 38 +++++++++++++++++---
 scene/main/viewport.h                     |  8 +++++
 servers/visual/visual_server_canvas.cpp   | 43 ++++++++++++++++-------
 servers/visual/visual_server_canvas.h     | 11 ++++--
 servers/visual/visual_server_raster.h     |  2 ++
 servers/visual/visual_server_viewport.cpp |  8 ++++-
 servers/visual/visual_server_viewport.h   |  4 ++-
 servers/visual/visual_server_wrap_mt.h    |  3 ++
 servers/visual_server.h                   |  2 ++
 11 files changed, 140 insertions(+), 25 deletions(-)

diff --git a/scene/2d/canvas_item.cpp b/scene/2d/canvas_item.cpp
index b605be47df6..ebb514f71cd 100644
--- a/scene/2d/canvas_item.cpp
+++ b/scene/2d/canvas_item.cpp
@@ -529,7 +529,7 @@ void CanvasItem::_enter_canvas() {
 			canvas = get_viewport()->find_world_2d()->get_canvas();
 
 		VisualServer::get_singleton()->canvas_item_set_parent(canvas_item, canvas);
-
+		VisualServer::get_singleton()->canvas_item_set_layer_mask(canvas_item, layers);
 		group = "root_canvas" + itos(canvas.get_id());
 
 		add_to_group(group);
@@ -546,6 +546,7 @@ void CanvasItem::_enter_canvas() {
 		canvas_layer = parent->canvas_layer;
 		VisualServer::get_singleton()->canvas_item_set_parent(canvas_item, parent->get_canvas_item());
 		VisualServer::get_singleton()->canvas_item_set_draw_index(canvas_item, get_index());
+		VisualServer::get_singleton()->canvas_item_set_layer_mask(canvas_item, layers);
 	}
 
 	pending_update = false;
@@ -1192,6 +1193,11 @@ void CanvasItem::_bind_methods() {
 	ClassDB::bind_method(D_METHOD("make_canvas_position_local", "screen_point"), &CanvasItem::make_canvas_position_local);
 	ClassDB::bind_method(D_METHOD("make_input_local", "event"), &CanvasItem::make_input_local);
 
+	ClassDB::bind_method(D_METHOD("set_layer_mask", "mask"), &CanvasItem::set_layer_mask);
+	ClassDB::bind_method(D_METHOD("get_layer_mask"), &CanvasItem::get_layer_mask);
+	ClassDB::bind_method(D_METHOD("set_layer_mask_bit", "layer", "enabled"), &CanvasItem::set_layer_mask_bit);
+	ClassDB::bind_method(D_METHOD("get_layer_mask_bit", "layer"), &CanvasItem::get_layer_mask_bit);
+
 	BIND_VMETHOD(MethodInfo("_draw"));
 
 	ADD_GROUP("Visibility", "");
@@ -1202,9 +1208,12 @@ void CanvasItem::_bind_methods() {
 	ADD_PROPERTY(PropertyInfo(Variant::BOOL, "show_on_top", PROPERTY_HINT_NONE, "", 0), "_set_on_top", "_is_on_top"); //compatibility
 	ADD_PROPERTY(PropertyInfo(Variant::INT, "light_mask", PROPERTY_HINT_LAYERS_2D_RENDER), "set_light_mask", "get_light_mask");
 
+	ADD_PROPERTY(PropertyInfo(Variant::INT, "layers", PROPERTY_HINT_LAYERS_2D_RENDER), "set_layer_mask", "get_layer_mask");
+
 	ADD_GROUP("Material", "");
 	ADD_PROPERTY(PropertyInfo(Variant::OBJECT, "material", PROPERTY_HINT_RESOURCE_TYPE, "ShaderMaterial,CanvasItemMaterial"), "set_material", "get_material");
 	ADD_PROPERTY(PropertyInfo(Variant::BOOL, "use_parent_material"), "set_use_parent_material", "get_use_parent_material");
+
 	//exporting these things doesn't really make much sense i think
 	// ADD_PROPERTY(PropertyInfo(Variant::BOOL, "toplevel", PROPERTY_HINT_NONE, "", PROPERTY_USAGE_NOEDITOR), "set_as_toplevel", "is_set_as_toplevel");
 	// ADD_PROPERTY(PropertyInfo(Variant::BOOL,"transform/notify"),"set_transform_notify","is_transform_notify_enabled");
@@ -1289,6 +1298,31 @@ int CanvasItem::get_canvas_layer() const {
 		return 0;
 }
 
+void CanvasItem::set_layer_mask(int p_mask) {
+
+	layers = p_mask;
+	VisualServer::get_singleton()->canvas_item_set_layer_mask(canvas_item, layers);
+}
+
+int CanvasItem::get_layer_mask() const {
+
+	return layers;
+}
+
+void CanvasItem::set_layer_mask_bit(int p_layer, bool p_enable) {
+	ERR_FAIL_INDEX(p_layer, 32);
+	if (p_enable) {
+		set_layer_mask(layers | (1 << p_layer));
+	} else {
+		set_layer_mask(layers & (~(1 << p_layer)));
+	}
+}
+
+bool CanvasItem::get_layer_mask_bit(int p_layer) const {
+	ERR_FAIL_INDEX_V(p_layer, 32, false);
+	return (layers & (1 << p_layer));
+}
+
 CanvasItem::CanvasItem() :
 		xform_change(this) {
 
@@ -1309,7 +1343,7 @@ CanvasItem::CanvasItem() :
 	notify_local_transform = false;
 	notify_transform = false;
 	light_mask = 1;
-
+	layers = 1;
 	C = NULL;
 }
 
diff --git a/scene/2d/canvas_item.h b/scene/2d/canvas_item.h
index 9c6799a441d..96c4e2ac05c 100644
--- a/scene/2d/canvas_item.h
+++ b/scene/2d/canvas_item.h
@@ -224,6 +224,8 @@ class CanvasItem : public Node {
 
 	static CanvasItem *current_item_drawn;
 
+	int layers;
+
 protected:
 	_FORCE_INLINE_ void _notify_transform() {
 		if (!is_inside_tree()) return;
@@ -300,6 +302,12 @@ class CanvasItem : public Node {
 	void set_self_modulate(const Color &p_self_modulate);
 	Color get_self_modulate() const;
 
+	void set_layer_mask(int p_mask);
+	int get_layer_mask() const;
+
+	void set_layer_mask_bit(int p_layer, bool p_enable);
+	bool get_layer_mask_bit(int p_layer) const;
+
 	/* DRAWING API */
 
 	void draw_line(const Point2 &p_from, const Point2 &p_to, const Color &p_color, float p_width = 1.0, bool p_antialiased = false);
diff --git a/scene/main/viewport.cpp b/scene/main/viewport.cpp
index 93eea2ad0bd..535a332fc38 100644
--- a/scene/main/viewport.cpp
+++ b/scene/main/viewport.cpp
@@ -267,6 +267,7 @@ void Viewport::_notification(int p_what) {
 			current_canvas = find_world_2d()->get_canvas();
 			VisualServer::get_singleton()->viewport_set_scenario(viewport, find_world()->get_scenario());
 			VisualServer::get_singleton()->viewport_attach_canvas(viewport, current_canvas);
+			VisualServer::get_singleton()->viewport_set_canvas_layer_mask(viewport, canvas_cull_mask);
 
 			_update_listener();
 			_update_listener_2d();
@@ -961,11 +962,6 @@ void Viewport::set_world_2d(const Ref<World2D> &p_world_2d) {
 	if (world_2d == p_world_2d)
 		return;
 
-	if (parent && parent->find_world_2d() == p_world_2d) {
-		WARN_PRINT("Unable to use parent world as world_2d");
-		return;
-	}
-
 	if (is_inside_tree()) {
 		find_world_2d()->_remove_viewport(this);
 		VisualServer::get_singleton()->viewport_remove_canvas(viewport, current_canvas);
@@ -2937,6 +2933,30 @@ void Viewport::_validate_property(PropertyInfo &property) const {
 	}
 }
 
+void Viewport::set_canvas_cull_mask(int p_layers) {
+	canvas_cull_mask = p_layers;
+	VisualServer::get_singleton()->viewport_set_canvas_layer_mask(viewport, canvas_cull_mask);
+}
+
+int Viewport::get_canvas_cull_mask() const {
+
+	return canvas_cull_mask;
+}
+
+void Viewport::set_canvas_cull_mask_bit(int p_layer, bool p_enable) {
+	ERR_FAIL_INDEX(p_layer, 32);
+	if (p_enable) {
+		set_canvas_cull_mask(canvas_cull_mask | (1 << p_layer));
+	} else {
+		set_canvas_cull_mask(canvas_cull_mask & (~(1 << p_layer)));
+	}
+}
+
+bool Viewport::get_canvas_cull_mask_bit(int p_layer) const {
+	ERR_FAIL_INDEX_V(p_layer, 32, false);
+	return (canvas_cull_mask & (1 << p_layer));
+}
+
 void Viewport::_bind_methods() {
 
 	ClassDB::bind_method(D_METHOD("set_use_arvr", "use"), &Viewport::set_use_arvr);
@@ -3059,6 +3079,12 @@ void Viewport::_bind_methods() {
 
 	ClassDB::bind_method(D_METHOD("_subwindow_visibility_changed"), &Viewport::_subwindow_visibility_changed);
 
+	ClassDB::bind_method(D_METHOD("set_canvas_cull_mask", "mask"), &Viewport::set_canvas_cull_mask);
+	ClassDB::bind_method(D_METHOD("get_canvas_cull_mask"), &Viewport::get_canvas_cull_mask);
+
+	ClassDB::bind_method(D_METHOD("set_canvas_cull_mask_bit", "layer", "enable"), &Viewport::set_canvas_cull_mask_bit);
+	ClassDB::bind_method(D_METHOD("get_canvas_cull_mask_bit", "layer"), &Viewport::get_canvas_cull_mask_bit);
+
 	ADD_PROPERTY(PropertyInfo(Variant::BOOL, "arvr"), "set_use_arvr", "use_arvr");
 
 	ADD_PROPERTY(PropertyInfo(Variant::VECTOR2, "size"), "set_size", "get_size");
@@ -3097,6 +3123,7 @@ void Viewport::_bind_methods() {
 	ADD_PROPERTY(PropertyInfo(Variant::TRANSFORM2D, "canvas_transform", PROPERTY_HINT_NONE, "", 0), "set_canvas_transform", "get_canvas_transform");
 	ADD_PROPERTY(PropertyInfo(Variant::TRANSFORM2D, "global_canvas_transform", PROPERTY_HINT_NONE, "", 0), "set_global_canvas_transform", "get_global_canvas_transform");
 
+	ADD_PROPERTY(PropertyInfo(Variant::INT, "canvas_cull_mask", PROPERTY_HINT_LAYERS_2D_RENDER), "set_canvas_cull_mask", "get_canvas_cull_mask");
 	ADD_SIGNAL(MethodInfo("size_changed"));
 
 	BIND_ENUM_CONSTANT(UPDATE_DISABLED);
@@ -3241,6 +3268,7 @@ Viewport::Viewport() {
 	local_input_handled = false;
 	handle_input_locally = true;
 	physics_last_id = 0; //ensures first time there will be a check
+	canvas_cull_mask = 0xfffff; // by default show everything
 }
 
 Viewport::~Viewport() {
diff --git a/scene/main/viewport.h b/scene/main/viewport.h
index 6393785b226..4a9f9083ff3 100644
--- a/scene/main/viewport.h
+++ b/scene/main/viewport.h
@@ -519,6 +519,14 @@ class Viewport : public Node {
 
 	bool gui_is_dragging() const;
 
+	int canvas_cull_mask;
+
+	void set_canvas_cull_mask(int p_layers);
+	int get_canvas_cull_mask() const;
+
+	void set_canvas_cull_mask_bit(int p_layer, bool p_enable);
+	bool get_canvas_cull_mask_bit(int p_layer) const;
+
 	Viewport();
 	~Viewport();
 };
diff --git a/servers/visual/visual_server_canvas.cpp b/servers/visual/visual_server_canvas.cpp
index f5a1276c27c..636688b3714 100644
--- a/servers/visual/visual_server_canvas.cpp
+++ b/servers/visual/visual_server_canvas.cpp
@@ -35,12 +35,12 @@
 
 static const int z_range = VS::CANVAS_ITEM_Z_MAX - VS::CANVAS_ITEM_Z_MIN + 1;
 
-void VisualServerCanvas::_render_canvas_item_tree(Item *p_canvas_item, const Transform2D &p_transform, const Rect2 &p_clip_rect, const Color &p_modulate, RasterizerCanvas::Light *p_lights) {
+void VisualServerCanvas::_render_canvas_item_tree(Item *p_canvas_item, const Transform2D &p_transform, const Rect2 &p_clip_rect, const Color &p_modulate, RasterizerCanvas::Light *p_lights, int mask) {
 
 	memset(z_list, 0, z_range * sizeof(RasterizerCanvas::Item *));
 	memset(z_last_list, 0, z_range * sizeof(RasterizerCanvas::Item *));
 
-	_render_canvas_item(p_canvas_item, p_transform, p_clip_rect, Color(1, 1, 1, 1), 0, z_list, z_last_list, NULL, NULL);
+	_render_canvas_item(p_canvas_item, p_transform, p_clip_rect, Color(1, 1, 1, 1), 0, z_list, z_last_list, NULL, NULL, mask);
 
 	for (int i = 0; i < z_range; i++) {
 		if (!z_list[i])
@@ -81,12 +81,15 @@ void _mark_ysort_dirty(VisualServerCanvas::Item *ysort_owner, RID_Owner<VisualSe
 	}
 }
 
-void VisualServerCanvas::_render_canvas_item(Item *p_canvas_item, const Transform2D &p_transform, const Rect2 &p_clip_rect, const Color &p_modulate, int p_z, RasterizerCanvas::Item **z_list, RasterizerCanvas::Item **z_last_list, Item *p_canvas_clip, Item *p_material_owner) {
+void VisualServerCanvas::_render_canvas_item(Item *p_canvas_item, const Transform2D &p_transform, const Rect2 &p_clip_rect, const Color &p_modulate, int p_z, RasterizerCanvas::Item **z_list, RasterizerCanvas::Item **z_last_list, Item *p_canvas_clip, Item *p_material_owner, int mask) {
 
 	Item *ci = p_canvas_item;
 
 	if (!ci->visible)
 		return;
+	if (!(ci->layer_mask & mask)) {
+		return;
+	}
 
 	if (ci->children_order_dirty) {
 
@@ -153,9 +156,9 @@ void VisualServerCanvas::_render_canvas_item(Item *p_canvas_item, const Transfor
 		if (!child_items[i]->behind || (ci->sort_y && child_items[i]->sort_y))
 			continue;
 		if (ci->sort_y) {
-			_render_canvas_item(child_items[i], xform * child_items[i]->ysort_xform, p_clip_rect, modulate * child_items[i]->ysort_modulate, p_z, z_list, z_last_list, (Item *)ci->final_clip_owner, (Item *)child_items[i]->material_owner);
+			_render_canvas_item(child_items[i], xform * child_items[i]->ysort_xform, p_clip_rect, modulate * child_items[i]->ysort_modulate, p_z, z_list, z_last_list, (Item *)ci->final_clip_owner, (Item *)child_items[i]->material_owner, mask);
 		} else {
-			_render_canvas_item(child_items[i], xform, p_clip_rect, modulate, p_z, z_list, z_last_list, (Item *)ci->final_clip_owner, p_material_owner);
+			_render_canvas_item(child_items[i], xform, p_clip_rect, modulate, p_z, z_list, z_last_list, (Item *)ci->final_clip_owner, p_material_owner, mask);
 		}
 	}
 
@@ -195,9 +198,9 @@ void VisualServerCanvas::_render_canvas_item(Item *p_canvas_item, const Transfor
 		if (child_items[i]->behind || (ci->sort_y && child_items[i]->sort_y))
 			continue;
 		if (ci->sort_y) {
-			_render_canvas_item(child_items[i], xform * child_items[i]->ysort_xform, p_clip_rect, modulate * child_items[i]->ysort_modulate, p_z, z_list, z_last_list, (Item *)ci->final_clip_owner, (Item *)child_items[i]->material_owner);
+			_render_canvas_item(child_items[i], xform * child_items[i]->ysort_xform, p_clip_rect, modulate * child_items[i]->ysort_modulate, p_z, z_list, z_last_list, (Item *)ci->final_clip_owner, (Item *)child_items[i]->material_owner, mask);
 		} else {
-			_render_canvas_item(child_items[i], xform, p_clip_rect, modulate, p_z, z_list, z_last_list, (Item *)ci->final_clip_owner, p_material_owner);
+			_render_canvas_item(child_items[i], xform, p_clip_rect, modulate, p_z, z_list, z_last_list, (Item *)ci->final_clip_owner, p_material_owner, mask);
 		}
 	}
 }
@@ -225,7 +228,7 @@ void VisualServerCanvas::_light_mask_canvas_items(int p_z, RasterizerCanvas::Ite
 	}
 }
 
-void VisualServerCanvas::render_canvas(Canvas *p_canvas, const Transform2D &p_transform, RasterizerCanvas::Light *p_lights, RasterizerCanvas::Light *p_masked_lights, const Rect2 &p_clip_rect) {
+void VisualServerCanvas::render_canvas(Canvas *p_canvas, const Transform2D &p_transform, RasterizerCanvas::Light *p_lights, RasterizerCanvas::Light *p_masked_lights, const Rect2 &p_clip_rect, int mask) {
 
 	VSG::canvas_render->canvas_begin();
 
@@ -256,7 +259,7 @@ void VisualServerCanvas::render_canvas(Canvas *p_canvas, const Transform2D &p_tr
 		memset(z_last_list, 0, z_range * sizeof(RasterizerCanvas::Item *));
 
 		for (int i = 0; i < l; i++) {
-			_render_canvas_item(ci[i].item, p_transform, p_clip_rect, Color(1, 1, 1, 1), 0, z_list, z_last_list, NULL, NULL);
+			_render_canvas_item(ci[i].item, p_transform, p_clip_rect, Color(1, 1, 1, 1), 0, z_list, z_last_list, NULL, NULL, mask);
 		}
 
 		for (int i = 0; i < z_range; i++) {
@@ -274,23 +277,23 @@ void VisualServerCanvas::render_canvas(Canvas *p_canvas, const Transform2D &p_tr
 		for (int i = 0; i < l; i++) {
 
 			const Canvas::ChildItem &ci2 = p_canvas->child_items[i];
-			_render_canvas_item_tree(ci2.item, p_transform, p_clip_rect, p_canvas->modulate, p_lights);
+			_render_canvas_item_tree(ci2.item, p_transform, p_clip_rect, p_canvas->modulate, p_lights, mask);
 
 			//mirroring (useful for scrolling backgrounds)
 			if (ci2.mirror.x != 0) {
 
 				Transform2D xform2 = p_transform * Transform2D(0, Vector2(ci2.mirror.x, 0));
-				_render_canvas_item_tree(ci2.item, xform2, p_clip_rect, p_canvas->modulate, p_lights);
+				_render_canvas_item_tree(ci2.item, xform2, p_clip_rect, p_canvas->modulate, p_lights, mask);
 			}
 			if (ci2.mirror.y != 0) {
 
 				Transform2D xform2 = p_transform * Transform2D(0, Vector2(0, ci2.mirror.y));
-				_render_canvas_item_tree(ci2.item, xform2, p_clip_rect, p_canvas->modulate, p_lights);
+				_render_canvas_item_tree(ci2.item, xform2, p_clip_rect, p_canvas->modulate, p_lights, mask);
 			}
 			if (ci2.mirror.y != 0 && ci2.mirror.x != 0) {
 
 				Transform2D xform2 = p_transform * Transform2D(0, ci2.mirror);
-				_render_canvas_item_tree(ci2.item, xform2, p_clip_rect, p_canvas->modulate, p_lights);
+				_render_canvas_item_tree(ci2.item, xform2, p_clip_rect, p_canvas->modulate, p_lights, mask);
 			}
 		}
 	}
@@ -411,6 +414,20 @@ void VisualServerCanvas::canvas_item_set_light_mask(RID p_item, int p_mask) {
 	canvas_item->light_mask = p_mask;
 }
 
+void VisualServerCanvas::canvas_item_set_layer_mask(RID p_item, int p_mask) {
+
+	Item *canvas_item = canvas_item_owner.getornull(p_item);
+	ERR_FAIL_COND(!canvas_item);
+
+	canvas_item->layer_mask = p_mask;
+}
+int VisualServerCanvas::canvas_item_get_layer_mask(RID p_item) {
+	Item *canvas_item = canvas_item_owner.getornull(p_item);
+	if (!canvas_item)
+		return 0;
+	return canvas_item->layer_mask;
+}
+
 void VisualServerCanvas::canvas_item_set_transform(RID p_item, const Transform2D &p_transform) {
 
 	Item *canvas_item = canvas_item_owner.getornull(p_item);
diff --git a/servers/visual/visual_server_canvas.h b/servers/visual/visual_server_canvas.h
index 822e3f8ce30..bb7e6a5b1de 100644
--- a/servers/visual/visual_server_canvas.h
+++ b/servers/visual/visual_server_canvas.h
@@ -52,6 +52,7 @@ class VisualServerCanvas {
 		Color ysort_modulate;
 		Transform2D ysort_xform;
 		Vector2 ysort_pos;
+		int layer_mask;
 
 		Vector<Item *> child_items;
 
@@ -68,6 +69,7 @@ class VisualServerCanvas {
 			ysort_children_count = -1;
 			ysort_xform = Transform2D();
 			ysort_pos = Vector2();
+			layer_mask = 0xfffff;
 		}
 	};
 
@@ -157,15 +159,15 @@ class VisualServerCanvas {
 	bool disable_scale;
 
 private:
-	void _render_canvas_item_tree(Item *p_canvas_item, const Transform2D &p_transform, const Rect2 &p_clip_rect, const Color &p_modulate, RasterizerCanvas::Light *p_lights);
-	void _render_canvas_item(Item *p_canvas_item, const Transform2D &p_transform, const Rect2 &p_clip_rect, const Color &p_modulate, int p_z, RasterizerCanvas::Item **z_list, RasterizerCanvas::Item **z_last_list, Item *p_canvas_clip, Item *p_material_owner);
+	void _render_canvas_item_tree(Item *p_canvas_item, const Transform2D &p_transform, const Rect2 &p_clip_rect, const Color &p_modulate, RasterizerCanvas::Light *p_lights, int mask);
+	void _render_canvas_item(Item *p_canvas_item, const Transform2D &p_transform, const Rect2 &p_clip_rect, const Color &p_modulate, int p_z, RasterizerCanvas::Item **z_list, RasterizerCanvas::Item **z_last_list, Item *p_canvas_clip, Item *p_material_owner, int mask);
 	void _light_mask_canvas_items(int p_z, RasterizerCanvas::Item *p_canvas_item, RasterizerCanvas::Light *p_masked_lights);
 
 	RasterizerCanvas::Item **z_list;
 	RasterizerCanvas::Item **z_last_list;
 
 public:
-	void render_canvas(Canvas *p_canvas, const Transform2D &p_transform, RasterizerCanvas::Light *p_lights, RasterizerCanvas::Light *p_masked_lights, const Rect2 &p_clip_rect);
+	void render_canvas(Canvas *p_canvas, const Transform2D &p_transform, RasterizerCanvas::Light *p_lights, RasterizerCanvas::Light *p_masked_lights, const Rect2 &p_clip_rect, int layer_mask);
 
 	RID canvas_create();
 	void canvas_set_item_mirroring(RID p_canvas, RID p_item, const Point2 &p_mirroring);
@@ -179,6 +181,9 @@ class VisualServerCanvas {
 	void canvas_item_set_visible(RID p_item, bool p_visible);
 	void canvas_item_set_light_mask(RID p_item, int p_mask);
 
+	void canvas_item_set_layer_mask(RID p_item, int p_mask);
+	int canvas_item_get_layer_mask(RID p_item);
+
 	void canvas_item_set_transform(RID p_item, const Transform2D &p_transform);
 	void canvas_item_set_clip(RID p_item, bool p_clip);
 	void canvas_item_set_distance_field_mode(RID p_item, bool p_enable);
diff --git a/servers/visual/visual_server_raster.h b/servers/visual/visual_server_raster.h
index dcfbd28dd61..4ab02d8ff7c 100644
--- a/servers/visual/visual_server_raster.h
+++ b/servers/visual/visual_server_raster.h
@@ -481,6 +481,7 @@ class VisualServerRaster : public VisualServer {
 	BIND2(viewport_set_msaa, RID, ViewportMSAA)
 	BIND2(viewport_set_hdr, RID, bool)
 	BIND2(viewport_set_usage, RID, ViewportUsage)
+	BIND2(viewport_set_canvas_layer_mask, RID, int)
 
 	BIND2R(int, viewport_get_render_info, RID, ViewportRenderInfo)
 	BIND2(viewport_set_debug_draw, RID, ViewportDebugDraw)
@@ -579,6 +580,7 @@ class VisualServerRaster : public VisualServer {
 
 	BIND2(canvas_item_set_visible, RID, bool)
 	BIND2(canvas_item_set_light_mask, RID, int)
+	BIND2(canvas_item_set_layer_mask, RID, int)
 
 	BIND2(canvas_item_set_update_when_visible, RID, bool)
 
diff --git a/servers/visual/visual_server_viewport.cpp b/servers/visual/visual_server_viewport.cpp
index 0863d5c2e31..1b68d94b6f4 100644
--- a/servers/visual/visual_server_viewport.cpp
+++ b/servers/visual/visual_server_viewport.cpp
@@ -237,7 +237,7 @@ void VisualServerViewport::_draw_viewport(Viewport *p_viewport, ARVRInterface::E
 				ptr = ptr->filter_next_ptr;
 			}
 
-			VSG::canvas->render_canvas(canvas, xform, canvas_lights, lights_with_mask, clip_rect);
+			VSG::canvas->render_canvas(canvas, xform, canvas_lights, lights_with_mask, clip_rect, p_viewport->canvas_layer_mask);
 			i++;
 
 			if (scenario_draw_canvas_bg && E->key().get_layer() >= scenario_canvas_max_layer) {
@@ -744,5 +744,11 @@ void VisualServerViewport::set_default_clear_color(const Color &p_color) {
 	clear_color = p_color;
 }
 
+void VisualServerViewport::viewport_set_canvas_layer_mask(RID p_viewport, int mask) {
+	Viewport *viewport = viewport_owner.getornull(p_viewport);
+	ERR_FAIL_COND(!viewport);
+	viewport->canvas_layer_mask = mask;
+}
+
 VisualServerViewport::VisualServerViewport() {
 }
diff --git a/servers/visual/visual_server_viewport.h b/servers/visual/visual_server_viewport.h
index bdd4c1d4f23..69008f1c4f2 100644
--- a/servers/visual/visual_server_viewport.h
+++ b/servers/visual/visual_server_viewport.h
@@ -77,6 +77,8 @@ class VisualServerViewport {
 
 		bool transparent_bg;
 
+		int canvas_layer_mask;
+
 		struct CanvasKey {
 
 			int64_t stacking;
@@ -185,7 +187,7 @@ class VisualServerViewport {
 
 	void viewport_set_global_canvas_transform(RID p_viewport, const Transform2D &p_transform);
 	void viewport_set_canvas_stacking(RID p_viewport, RID p_canvas, int p_layer, int p_sublayer);
-
+	void viewport_set_canvas_layer_mask(RID p_viewport, int mask);
 	void viewport_set_shadow_atlas_size(RID p_viewport, int p_size);
 	void viewport_set_shadow_atlas_quadrant_subdivision(RID p_viewport, int p_quadrant, int p_subdiv);
 
diff --git a/servers/visual/visual_server_wrap_mt.h b/servers/visual/visual_server_wrap_mt.h
index 41993d7c88a..6a1cdf2cf03 100644
--- a/servers/visual/visual_server_wrap_mt.h
+++ b/servers/visual/visual_server_wrap_mt.h
@@ -409,6 +409,8 @@ class VisualServerWrapMT : public VisualServer {
 	FUNC2(viewport_set_hdr, RID, bool)
 	FUNC2(viewport_set_usage, RID, ViewportUsage)
 
+	FUNC2(viewport_set_canvas_layer_mask, RID, int)
+
 	//this passes directly to avoid stalling, but it's pretty dangerous, so don't call after freeing a viewport
 	virtual int viewport_get_render_info(RID p_viewport, ViewportRenderInfo p_info) {
 		return visual_server->viewport_get_render_info(p_viewport, p_info);
@@ -497,6 +499,7 @@ class VisualServerWrapMT : public VisualServer {
 
 	FUNC2(canvas_item_set_visible, RID, bool)
 	FUNC2(canvas_item_set_light_mask, RID, int)
+	FUNC2(canvas_item_set_layer_mask, RID, int)
 
 	FUNC2(canvas_item_set_update_when_visible, RID, bool)
 
diff --git a/servers/visual_server.h b/servers/visual_server.h
index 1b0164e5caf..440f3f27e84 100644
--- a/servers/visual_server.h
+++ b/servers/visual_server.h
@@ -610,6 +610,7 @@ class VisualServer : public Object {
 	virtual void viewport_attach_to_screen(RID p_viewport, const Rect2 &p_rect = Rect2(), int p_screen = 0) = 0;
 	virtual void viewport_set_render_direct_to_screen(RID p_viewport, bool p_enable) = 0;
 	virtual void viewport_detach(RID p_viewport) = 0;
+	virtual void viewport_set_canvas_layer_mask(RID p_viewport, int mask) = 0;
 
 	enum ViewportUpdateMode {
 		VIEWPORT_UPDATE_DISABLED,
@@ -872,6 +873,7 @@ class VisualServer : public Object {
 
 	virtual void canvas_item_set_visible(RID p_item, bool p_visible) = 0;
 	virtual void canvas_item_set_light_mask(RID p_item, int p_mask) = 0;
+	virtual void canvas_item_set_layer_mask(RID p_item, int p_mask) = 0;
 
 	virtual void canvas_item_set_update_when_visible(RID p_item, bool p_update) = 0;

